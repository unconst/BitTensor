
Major Needs:

  [1] The proto buffs needs to be switched out for bittensor.proto.
    [1.1] This will require rewriting the servers to accommodate the change.
    [1.1] Need to create the signature proof from the private keys.

  [1] Need to use actual EOS addresses at the nodes.

  [1] Rate limiting and ip blocking unless the channel is set in the metagraph.

  [1] Apply SGD steps with weighted averages in the boltzmann nodes.

  [1] We need XLM, ELMO, ERNIE, TransformerXL, Roberta, etc as Nuerons.
  Some should be easy because they follow the standard text --> tenso representations

  [1] Trainable versions of the above.

  [1] Why can't I use Kubernetes to throw up lots of nodes.

  [1] The Docker image it too large. Should be running off of Alpine linux.

  [1] Right now the token is not live, instead the stake vector is stored in a map.
  Look at the EOS contract. We need to connect the EOS token contract with the stake vector.
  You can send etc.

    [1.1] We need work with the token emission scheme to see if people can easily
    cheat, and if emission for nothing is a serious issue.

  [1] The README.md needs a description of the Boltzmann Node.

  [1] The README.md needs a better proportional allocation game description.

  [1] We need a client tf and pytorch operation

    [1.1] spikes = bittensor.spike(my_address, my_text)
    -- op should return errors if the address is not subscribed.
    -- op should have permissions to make k connections.
    -- people need to be able to get EOS somehow and easily connect it to this operation.
    This op needs to be differentiable. I actually already did this in BitTensorSupervised.

    [1.1] When a client connects to the graph they should query the top k attributing nodes.
    This will give the system structure.

    [1.1] There is no distillation occurring here. There needs to be. Make tools
      and examples for using distillation to pull knowledge from the network.





./Emission testing.ipynb:119:    "        # TODO(const): It is not yet obvious if tokens that are held out of the metagraph should be attaining emission.\n",
./Emission testing.ipynb:191:    "        # TODO(const): I am uncertain of the EOS token requirements this function requires, or what happens when a \n",
./Emission testing.ipynb:381:    "        # TODO(const): It is not yet obvious if tokens that are held out of the metagraph should be attaining emission.\n",
./Emission testing.ipynb:465:    "        # TODO(const): I am uncertain of the EOS token requirements this function requires, or what happens whena \n",
./contract/bittensor/bittensor.cpp:24:    // TODO(const): We need to sub the balance from the bittensor pool
./contract/bittensor/bittensor.cpp:27:    // TODO(const): We need to be able to update subscribe here. Change IP for
./contract/bittensor/bittensor.cpp:72:    // TODO(const): We need to add the balance back into the bittensor pool
./contract/bittensor/bittensor.cpp:213:  // TODO(const): This should be done in a way that keeps the precision of the
./bittensor.sh:44:# TODO(const) Should be root dir.
./docs/links.txt:8:# TODO (const): Outrageously large NNs Shazeer
./docs/links.txt:9:# TODO (const): Multitask learning Gomez
./docs/links.txt:10:# TODO (const): AHAH computing
./docs/links.txt:11:# TODO (const): distillation
./docs/links.txt:12:# TODO (const): Fishers information pruning
./docs/links.txt:13:# TODO (const): Catastrophic forgetting.
./docs/links.txt:14:# TODO (const): Bitcoin & Ethereum & EOS
./docs/links.txt:15:# TODO (const): IPFS, BitTorrent
./README.md:57:## To-Run-Remotely (TODO)
./.gitignore:3:# TODO(const) This folder should be set with a var.
./scripts/bittensor.sh:130:  # TODO(const) In the future this could be preset and contain our conf file.
./scripts/bittensor.sh:149:  # TODO(const) These are currently hard coded to eosio main. In prodution this
./scripts/todo.sh:1:rm -f TODO.txt
./scripts/todo.sh:2:grep -rnw . -e 'TODO' > TODO.txt
./scripts/init_eos.sh:53:# TODO(const) "bittensoracc" by a new account in production.
./.ipynb_checkpoints/Emission testing-checkpoint.ipynb:119:    "        # TODO(const): It is not yet obvious if tokens that are held out of the metagraph should be attaining emission.\n",
./.ipynb_checkpoints/Emission testing-checkpoint.ipynb:191:    "        # TODO(const): I am uncertain of the EOS token requirements this function requires, or what happens whena \n",
./.ipynb_checkpoints/Emission testing-checkpoint.ipynb:357:    "        # TODO(const): It is not yet obvious if tokens that are held out of the metagraph should be attaining emission.\n",
./.ipynb_checkpoints/Emission testing-checkpoint.ipynb:441:    "        # TODO(const): I am uncertain of the EOS token requirements this function requires, or what happens whena \n",
Binary file ./.git/index matches
./src/proto/tensorflow/core/framework/tensor.proto:12:  // Shape of the tensor.  TODO(touts): sort out the 0-rank issues.
./src/nucleus.py:96:        # TODO(const) Add distillation networks for each dendrite.
./src/nucleus.py:140:        # TODO(const) implement distillation pipeline here. During inference this should be run through the distilled network.
./src/nucleus.py:172:        # TODO(const) More than one layer?
./src/nucleus.py:293:        # TODO(const): Attribution scores should be posted to tensorboard
./src/nucleus.py:309:                    # TODO(const) Problematic! This is not thead safe.
./src/nucleus.py:379:                # TODO(const) Need to implement the validation loop here.
./src/metagraph.py:45:# TODO (const): Pull Token supply.
./src/metagraph.py:46:# TODO (const): Call Token Emit.
./src/metagraph.py:47:# TODO (const): Calculate attribution derivatives for synapse prunning.
./src/metagraph.py:56:        # TODO(const) this should be our own key. NOT EOSMAIN.
./src/metagraph.py:62:    # TODO(const): pull this from the eos chain under the var 'total stake'
./src/metagraph.py:79:            # TODO (const) Rewrite the cleos library for our selves.
./src/synapse.py:7:# TODO (const): Rate limit and block ip.
./src/synapse.py:71:        # TODO (const) The synapse should be competitively selecting which nodes
./src/main.py:37:    # TODO(const) perhaps this should be removed. Instead downstream state is
./src/main.py:45:    # TODO(const) Use Hparams and FLAGS like in ARC nets.
./src/main.py:59:    # TODO(const) Market driven bidding for neighbors with FAN-IN K value.
./src/dendrite.py:18:# TODO (const): Negotiate channels with upstream nodes.
./src/dendrite.py:65:        # TODO(const) Implement distillation here for inference.
./src/dendrite.py:66:        # TODO(const) Implement sub networks for each dendrite.
./src/dendrite.py:75:        # TODO(const) Currently this function is syncronous. Calls to the
./src/dendrite.py:101:            # TODO(const) This should be a special tf.operation.
